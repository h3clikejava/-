# Java API调优 【集合类】

集合类底层用数组实现的，因此随着元素的增加，调整大小会导致开销很大。

## 集合内部避免返回Null

当一个函数需要返回数组或集合的时候，要避免直接返回Null。这里并不是说不能返回Null，而是返回Null之后需要判空，否则会抛出空指针异常。这样做只是为了让代码更美观简洁。
有的人会认为返回一个空数组或空集合需要花费时间和空间，其实可以使用公用对象来减少性能影响。
自己写的接口尽量遵循这个规范，并在接口说明中标明。

```
public String[] getBooks() {
    if(book.size() == 0)
        // 不建议用这样的返回
        return null;
    ...
}

private static final String[] NULL = new String[0];
public String[] getBooks2() {
    if(book.size() == 0) 
        return NULL;
    ...
}
public List<String> getBooks3() {
    if(book.size() == 0) 
        return Collections.emptyList();
        // Collections.emptyMap()
        // Collections.emptySet();
    ...
}
```

**特别注意：**

* Collections.emptyX()方法返回的对象都是**immutable**的，即不可更改，如果对该集合进行增删操作会导致UnsupportedOperationException异常。
* List转换为数组，直接使用toArray()方法即可，后面参数可以不写。写参数时，如果数组长度比集合长，会将多余的数组元素赋空；如果数组长度比集合短，会自动创建集合长度的数组。

## ArrayList/LinkedList

ArrayList、Vector、LinkedList均继承自AbstractList，AbstractList继承自AbstractCollection，并实现List接口。

ArrayList和Vector底层用数组实现，ArrayList是线程不安全的，而Vector是线程安全的。LinkedList是采用的双向链表实现。

ArrayList超过数组预定义最大限度时，需要对数组进行扩容，扩容过程会执行大量复制操作。而LinkedList使用链表结构，无需扩容。

### ArrayList

优势就是**读取**和**搜索**速度很快，删除数据开销很大，数组需要重排。

### LinkedList

优势就是**插入**数据很快，这里要注意的是LinkedList用的是链表结构，因此每次获取数据都要从第一个元素开始遍历，因此数据越多性能越慢。但是即便是这样其**删除**数据也比ArrayListy要快。

```
LinkedList list;
for(int n = 0; n < list.size; n++) {
    // 不要这样使用LinkedList
    // 否则每次get都是从第一个元素开始遍历
    list.get(n);
}

// 推荐这样遍历
Iterator iterator = list.iterator();
while(iterator.hasNext())
```

因此当数据增删不是很频繁的情况下，尽量优先使用ArrayList；反之当数据需要频繁增删，查询较少，很少用到get(index)的时候，应该使用LinkedList。这里需要结合自身业务需求，而不是盲目使用ArrayList。

### RandomAccess

RandomAccess是一个接口，它本身并没有提供任何方法，只是用来标识哪些类可以支持快速随机访问。

任何基于数组的List都实现了RandomAccess接口，而基于链表结构的都没有。因为只有数组才能快速随机访问，而链表只能通过遍历的方式访问。因此可以根据是否支持RandomAccess来优化程序性能。

```
if(list instanceof RandomAccess) {
    for(int n = 0; n < list.size; n++);
} else {
    Iterator iterator = list.iterator();
    while(iterator.hasNext());
}
```


### foreach
foreach是一种高效的迭代器，其与iterator的区别就是foreach不支持迭代过程中remove对象。因此无论对象是否支持RandomAccess，用foreach迭代效率是最高的。

## Vector/HashTable

vector是线程安全的ArrayList，它会对所有操作进行加锁，所以一般情况下不要使用。

HashTable是线程安全的HashMap，HashTable无论是Key或者Value都不允许Null值，HashMap没有要求。

尽管如此，平时在开发过程中也尽量不要使用Vector和HashTable，用Collections.synchronizedList(list)或Collections.synchronizedMap(map)来实现。

## HashMap/HashSet

HashMap实际上是链表数组。HashSet是由HashMap实现的，即使用Key存储，而Value存储了一个PRESENT，是一个静态的Object对象。

###既然HashSet是由HashMap实现的，HashMap又支持存储Null对象，为什么HashSet底层的Value是PRESENT对象而不是空呢？

![HashSet Value](https://pic2.zhimg.com/80/v2-dfb154a2ff37b9f790cca23b8910cfec_hd.jpg)

这是一个好问题，查看HashSet源码可知，HashSet.add()方法会返回一个boolean来表示该Key之前是否有插入过。而HashMap.add()方法会返回之前该Key插入的Value，如果该Key没有插入过即返回Null。如果HashSet的Value默认值是Null，那就不知道该Key之前是否插入过了。

## EnumSet/EnumMap

在存放枚举类型的时候，效率高于HashSet/HashMap

## LinkedHashMap/TreeMap

LinkedHashMap继承自HashMap，它在其基础上又在内部增加了一个链表，用以存放元素的插入顺序。

TreeMap会直接根据元素的Key进行排序。

