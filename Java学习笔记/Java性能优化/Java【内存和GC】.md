# Java内存和GC

## Java内存分配
Java程序对内存分配的方式一般有三种：
1. 从静态存储区域分配。内存在程序预编译的时候就已经分配好，这块内存在整个程序运行期间都存在。例如全局变量、static变量。
2. 在栈上创建。在执行函数时函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于CPU的指令集中，效率很高，但是分配的内存容量有限。
3. 在堆上分配，亦称动态内存分配。程序在运行的时候用new申请内存。

## JVM内存模型
![JVM内存模型](http://img.blog.csdn.net/20150720152805765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

运行时数据区包括五个部分：**方法区**、**堆**、**虚拟机栈**、**本地方法栈**、**程序计数器**。

**方法区**
类型信息、字段信息、方法信息、其他信息。

**堆**：

存放各种对象实例。所有的对象的内存都在这里分配。垃圾回收主要就是作用于这里的。

* 堆得内存由-Xms指定，默认是物理内存的1/64；最大的内存由-Xmx指定，默认是物理内存的1/4。
* 默认空余的堆内存小于40%时，就会增大，直到-Xmx设置的内存。具体的比例可以由-XX:MinHeapFreeRatio指定
* 空余的内存大于70%时，就会减少内存，直到-Xms设置的大小。具体由-XX:MaxHeapFreeRatio指定。

因此一般都建议把这两个参数设置成一样大，可以避免JVM在不断调整大小。

**虚拟机栈**：

存放基本数据类型和引用。它是一种在RAM上通过“栈指针”可以被快速访问的存储区域，栈指针向下移动会分配新的内存，向上移动则释放内存。

* **线程私有**，生命周期与线程相同。每个方法执行的时候都会创建一个栈帧（stack frame）用于存放局部变量表、操作栈、动态链接、方法出口。
* **数据共享性**

```
    // 在栈中创建a的引用，并且存放1这个值
    int a = 1;
    // 在栈中创建b的引用，直接使用1这个值
    int b = 1;
```

* JVM规定栈大小可以是动态的也可以是固定的，如果栈大小是固定的，超过其大小之后会抛出**StackOverflowError**异常；如果栈大小是动态的，超过内存大小后会抛出**OutOfMemory**异常。栈的大小可以通过-XSs设置。
* **Android**程序栈内存大小仅为**8M**，不受操作系统版本及其他因素影响。

```
/**
 * 测试虚拟机栈大小
 **/
public class TestJVMStack {
    private int i = 0;
    
    public void recursion() {
        i++;
        recursion();
    }

    public static void main(String[] args) {
        try {
            new TestJVMStack().recursion();
        } catch (Throwable e) {
            System.out.println("deep of stack is " + i);
        }
    }
}
```

**程序计数器**

这里记录了线程执行的字节码的行号，在分支、循环、跳转、异常、线程恢复等都依赖这个计数器。它是线程私有的空间，每个线程都有一个程序计数器。

**堆与栈分开设计是为什么呢？**

* 栈存储了处理逻辑、堆存储了具体的数据，这样隔离设计更为清晰
* 堆与栈分离，使得堆可以被多个栈共享。
* 栈通过上下移动指针来动态调整内存空间，它的优势就是**快**，并且在程序创建的时候就确定了大小，因此相对于**堆**不够灵活。
* 方法内定义的变量全部在栈中，方法外定义的变量无论是否为基础数据类型都在堆中。静态变量在方法区，也算在堆中。

## 栈帧(Stack fame)
![JVM存放示意图](https://pic3.zhimg.com/80/96c5e28ae772a6f0e732cebd39ef57aa_hd.jpg)

JVM在运行的时候使用**栈帧**保存上下文数据，是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧里面存放了**方法的局部变量表**、**操作数栈**、**动态连接方法**和**返回地址**等信息。

**一个方法对应一个栈帧**，每一个方法的调用都伴随着栈帧入栈操作，相应的方法返回则表示栈帧出栈。如果方法调用时方法的参数和局部变量较多，那么栈帧中局部变量表就会较大，栈帧会不断膨胀以满足方法调用，因此该栈空间大小也会较大。

### 局部变量对垃圾回收的影响
局部变量表中的变量是很重要的垃圾回收根节点，被局部变量表中变量直接或者间接引用的对象都不会被回收。

#### 实验
```
public class GcTest { 
    private static final int SIZE = 6 * 1024 * 1024; 
    public static void localVarGc1() { 
        byte[] b = new byte[SIZE]; 
        System.gc(); 
    } 
    public static void localVarGc2() { 
        byte[] b = new byte[SIZE]; 
        b = null; 
        System.gc(); 
    }
    public static void localVarGc3() { 
        { 
            byte[] b = new byte[SIZE]; 
        } 
        System.gc(); 
    } 
    public static void localVarGc4() { 
        { 
            byte[] b = new byte[SIZE]; 
        } 
        int c = 0; 
        System.gc(); 
    } 
    public static void localVarGc5() { 
        localVarGc1(); 
        System.gc(); 
    } 
    public static void main(String[] args) { 
        // localVarGc1(); // 没有GC 
        // localVarGc2(); // GC 
        // localVarGc3(); // 没有GC 
        // localVarGc4(); // GC 
        // localVarGc5(); // GC } 
    }
```

注意看这个例子：
1. 申请了一个6M大小的空间，赋值给b引用，然后调用GC函数，因为此时这个6M的空间还被b引用着，所以不能顺利GC；
2. 申请了一个6M大小的空间，赋值给b引用，然后将b重新赋值为null，此时这个6M的空间不再被b引用，所以可以顺利**GC**；
3. 申请了一个6M大小的空间，赋值给b引用，过了b的作用范围之后调用GC函数，但是因为此时b并没有被销毁，还存在于栈帧中，这个空间也还被b引用，所以不能顺利GC；
4. 申请了一个6M大小的空间，赋值给b引用，过了b的作用范围之后重新创建一个变量c，此时这个新的变量会**复用**已经失效的b变量的**槽位**，所以b**被迫销毁**了，所以6M的空间没有被任何变量引用，于是能够顺利**GC**；
5. 首先调用localVarGc1()，很显然不能顺利GC，函数调用结束之后再调用GC函数，此时因为localVarGc1这个函数的栈帧已经随着函数调用的结束而被销毁，b也就被销毁了，所以6M大小的空间不被任何对象引用，于是能够顺利**GC**。

这里有个概念不要搞错了，这里的不能顺利GC指的是在**函数体内**无法被GC，当函数执行完成之后仍然会被GC，因此不会存在内存泄漏的情况。但是我们引出**槽位复用**的概念就是为了告诉大家，在函数执行过程中，如果没有复用槽位会导致失效的变量继续占用内存空间，直至函数执行完毕。为了高效的使用内存或节省空间，我们应该在函数体中将不会进行槽位复用的变量置空。

## 虚引用(Phantom Reference)

它的get方法永远会返回Null。虚引用主要用于检测对象是否已经从内存中删除。

```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
```

### 引用队列

虚引用不能单独使用，需要和引用队列（）配合使用。当某个对象被finalize方法调用之后，这个对象的虚引用会被加入到引用队列中，通过检查该队列里的内容来检查对象是否被回收。

## Java垃圾回收机制

垃圾回收器主要负责三个任务：分配内存、确保引用的对象内存不被错误回收、回收不在引用的对象内存空间。垃圾回收是一个复杂且耗时的操作，过多的GC会影响运行性能。一般情况下垃圾回收在执行回收操作的时候，整个应用的执行是被暂时中止的，因为需要更新所有引用对象的内存地址（比如对象从年轻代复制到年老代）。

垃圾回收最基本的做法就是分代回收，一般分为年轻代、年老代和永久代。内存的分配是反正在年轻代中的，当一个对象存活的时间够久，就会被复制到年老代中，JVM会对不同世代的内存采用不同的回收算法。

年轻代进一步划分，可分为伊甸园（Eden）和两个存活区（survivor space）。伊甸园是进行内存分配的地方，是一块连续的空闲内存区域，在上面分配内存不需要进行可用块查找因此速度非常的快。两个存活区始终有一个是空白的。当进行内存回收的时候，伊甸园和一个非空存活区会根据存活时间被复制到空白存活区或年老代中，伊甸园和非空存活区内存会被清空。

年老代和永久代采用“标记-清除-压缩（Mark-Sweep-Compact）”回收算法。标记是找出当前还存活的对象，并进行标记；清除则遍历整个内存区，找出需要进行回收的区域；而压缩则把存活对象内存移动到整个内存区的一端，使得另一端是一块连续的空闲区域，方便进行内存的分配和复制。

## finalize()
当GC需要回收对象的时候，会回调对象中的该方法，可以在其中做一些清理释放工作。

这里特别注意的是，由于finalize方法的存在，虚拟机中的对象有三种状态：

1. 可达状态，指该对象被引用，其中包括强应用、软引用、弱引用。
2. 可复活状态。虽然只有当对象没有引用的时候才会调用finalize方法，但是复写该方法后可能会对当前对象产生新的引用。因此当finalize方法运行完毕之后，GC会重新检查该对象状态，如果发现了新的引用相当于复活该对象，否则会释放该对象。当对象被复活之后，至下一次发现没有引用时，该对象会直接变为不可达状态。也就说一个对象的finalize方法只会被调用一次。
3. 不可达状态，会被GC回收掉。

finalize方法存在的意义主要是为了回收一些非Java对象。比如用C或JNI之类创建的内存空间无法被GC回收，当GC调用finalize方法的时候可以手动回收这些资源。

---
### 小知识
* 寄存器（CPU中）是最快的存储区域，其次是Cache，再其次是RAM（运行时内存，断电内容丢失，相当于台式机内存条），然后是ROM（断点之后内容不会丢失，相当于台式机硬盘），最后是外存储器(相当于U盘，存储卡)。

![计算机硬件组成图](https://pic3.zhimg.com/80/8bf6ef80ddbcd9ed5984fe9a51bb5b78_hd.jpg)

* JVM垃圾回收除了要处理垃圾回收之外，还会处理堆内存的碎片整理。finalize()和System.gc()只是通知系统进行垃圾回收，但是具体是否执行仍要看相关JVM垃圾回收逻辑。

