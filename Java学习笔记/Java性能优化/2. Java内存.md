# Java内存

## Java内存分配
Java程序对内存分配的方式一般有三种：
1. 从静态存储区域分配。内存在程序预编译的时候就已经分配好，这块内存在整个程序运行期间都存在。例如全局变量、static变量。
2. 在栈上创建。在执行函数时函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于CPU的指令集中，效率很高，但是分配的内存容量有限。
3. 在堆上分配，亦称动态内存分配。程序在运行的时候用new申请内存。

## JVM内存模型
![JVM内存模型](http://img.blog.csdn.net/20150720152805765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

运行时数据区包括五个部分：**方法区**、**堆**、**虚拟机栈**、**本地方法栈**、**程序计数器**。

**方法区**
类型信息、字段信息、方法信息、其他信息。

**堆**：

存放各种对象实例。所有的对象的内存都在这里分配。垃圾回收主要就是作用于这里的。

* 堆得内存由-Xms指定，默认是物理内存的1/64；最大的内存由-Xmx指定，默认是物理内存的1/4。
* 默认空余的堆内存小于40%时，就会增大，直到-Xmx设置的内存。具体的比例可以由-XX:MinHeapFreeRatio指定
* 空余的内存大于70%时，就会减少内存，直到-Xms设置的大小。具体由-XX:MaxHeapFreeRatio指定。

因此一般都建议把这两个参数设置成一样大，可以避免JVM在不断调整大小。

**虚拟机栈**：

存放基本数据类型和引用。它是一种在RAM上通过“栈指针”可以被快速访问的存储区域，栈指针向下移动会分配新的内存，向上移动则释放内存。

* **线程私有**，生命周期与线程相同。每个方法执行的时候都会创建一个栈帧（stack frame）用于存放局部变量表、操作栈、动态链接、方法出口。
* **数据共享性**

```
    // 在栈中创建a的引用，并且存放1这个值
    int a = 1;
    // 在栈中创建b的引用，直接使用1这个值
    int b = 1;
```

* JVM规定栈大小可以是动态的也可以是固定的，如果栈大小是固定的，超过其大小之后会抛出**StackOverflowError**异常；如果栈大小是动态的，超过内存大小后会抛出**OutOfMemory**异常。栈的大小可以通过-XSs设置。
* **Android**程序栈内存大小仅为**8M**，不受操作系统版本及其他因素影响。

```
/**
 * 测试虚拟机栈大小
 **/
public class TestJVMStack {
    private int i = 0;
    
    public void recursion() {
        i++;
        recursion();
    }

    public static void main(String[] args) {
        try {
            new TestJVMStack().recursion();
        } catch (Throwable e) {
            System.out.println("deep of stack is " + i);
        }
    }
}
```

**程序计数器**

这里记录了线程执行的字节码的行号，在分支、循环、跳转、异常、线程恢复等都依赖这个计数器。它是线程私有的空间，每个线程都有一个程序计数器。

**堆与栈分开设计是为什么呢？**

* 栈存储了处理逻辑、堆存储了具体的数据，这样隔离设计更为清晰
* 堆与栈分离，使得堆可以被多个栈共享。
* 栈通过上下移动指针来动态调整内存空间，它的优势就是**快**，并且在程序创建的时候就确定了大小，因此相对于**堆**不够灵活。

## 栈帧(Stack fame)
![JVM存放示意图](https://pic3.zhimg.com/80/96c5e28ae772a6f0e732cebd39ef57aa_hd.jpg)

JVM在运行的时候使用**栈帧**保存上下文数据，是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧里面存放了**方法的局部变量表**、**操作数栈**、**动态连接方法**和**返回地址**等信息。

**一个方法对应一个栈帧**，每一个方法的调用都伴随着栈帧入栈操作，相应的方法返回则表示栈帧出栈。如果方法调用时方法的参数和局部变量较多，那么栈帧中局部变量表就会较大，栈帧会不断膨胀以满足方法调用，因此该栈空间大小也会较大。

### 局部变量对垃圾回收的影响
局部变量表中的变量是很重要的垃圾回收根节点，被局部变量表中变量直接或者间接引用的对象都不会被回收。

#### 实验
```
public class GcTest { 
    private static final int SIZE = 6 * 1024 * 1024; 
    public static void localVarGc1() { 
        byte[] b = new byte[SIZE]; 
        System.gc(); 
    } 
    public static void localVarGc2() { 
        byte[] b = new byte[SIZE]; 
        b = null; 
        System.gc(); 
    }
    public static void localVarGc3() { 
        { 
            byte[] b = new byte[SIZE]; 
        } 
        System.gc(); 
    } 
    public static void localVarGc4() { 
        { 
            byte[] b = new byte[SIZE]; 
        } 
        int c = 0; 
        System.gc(); 
    } 
    public static void localVarGc5() { 
        localVarGc1(); 
        System.gc(); 
    } 
    public static void main(String[] args) { 
        // localVarGc1(); // 没有GC 
        // localVarGc2(); // GC 
        // localVarGc3(); // 没有GC 
        // localVarGc4(); // GC 
        // localVarGc5(); // GC } 
    }
```

注意看这个例子：
1. 申请了一个6M大小的空间，赋值给b引用，然后调用GC函数，因为此时这个6M的空间还被b引用着，所以不能顺利GC；
2. 申请了一个6M大小的空间，赋值给b引用，然后将b重新赋值为null，此时这个6M的空间不再被b引用，所以可以顺利**GC**；
3. 申请了一个6M大小的空间，赋值给b引用，过了b的作用返回之后调用GC函数，但是因为此时b并没有被销毁，还存在于栈帧中，这个空间也还被b引用，所以不能顺利GC；
4. 申请了一个6M大小的空间，赋值给b引用，过了b的作用返回之后重新创建一个变量c，此时这个新的变量会**复用**已经失效的b变量的**槽位**，所以b**被迫销毁**了，所以6M的空间没有被任何变量引用，于是能够顺利**GC**；
5. 首先调用localVarGc1()，很显然不能顺利GC，函数调用结束之后再调用GC函数，此时因为localVarGc1这个函数的栈帧已经随着函数调用的结束而被销毁，b也就被销毁了，所以6M大小的空间不被任何对象引用，于是能够顺利**GC**。

这里有个概念不要搞错了，这里的不能顺利GC指的是在**函数体内**无法被GC，当函数执行完成之后仍然会被GC，因此不会存在内存泄漏的情况。但是我们引出**槽位复用**的概念就是为了告诉大家，在函数执行过程中，如果没有复用槽位会导致失效的变量继续占用内存空间，直至函数执行完毕。为了高效的使用内存或节省空间，我们应该在函数体中将不会进行槽位复用的变量置空。

---
### 小知识
* 寄存器（CPU中）是最快的存储区域，其次是Cache，再其次是RAM（运行时内存，断电内容丢失，相当于台式机内存条），然后是ROM（断点之后内容不会丢失，相当于台式机硬盘），最后是外存储器(相当于U盘，存储卡)。

![计算机硬件组成图](https://pic3.zhimg.com/80/8bf6ef80ddbcd9ed5984fe9a51bb5b78_hd.jpg)

